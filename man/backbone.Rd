% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/backbone.R
\name{backbone}
\alias{backbone}
\title{Compute a backbone, i.e., a simplified graph-structured topology, of a given graph or point cloud data set X.}
\usage{
backbone(
  X,
  type = "knn",
  k = 10,
  eps = NULL,
  f = NULL,
  CLOF_vcost = betweenness,
  CLOF_ecost = NULL,
  max_leaves = NA,
  leaves = NA,
  preprune = TRUE,
  stdize = FALSE,
  assign = FALSE,
  prob = TRUE,
  constrain_mem = FALSE
)
}
\arguments{
\item{X}{Data for which a backbone is to be computed in igraph/data.frame/matrix/dist format. or a 'matrix'
In all but the former case, a proximity graph G is constructed.
Otherwise G = X is used.}

\item{type}{(Optional) Used if X is not in igraph format.
Must be either 'knn' if kNN graph is to be constructed, or 'rips' if Vietoris-Rips graph is to be constructed.
Standard is 'knn'}

\item{k}{(Optional) Number of neighbors to be used when a kNN graph G is constructed from X.
Standard is 10.}

\item{eps}{(Optional) Distance parameter to be used when a (Vietoris-)Rips graph G is constructed from X.
Must be provided if X is not in igraph format and type is rips.}

\item{f}{(Optional) function values to compute f-pine.
Boundary coefficients are computed and used if not provided.}

\item{CLOF_vcost}{(Optional) vertex valued function used to solve CLOF.
Standard is vertex betweenness.}

\item{CLOF_ecost}{(Optional) edge valued function used to solve CLOF.
Standard is NULL, and a vertex valued function is used.
If not NULL, CLOF_vcost is ignored.}

\item{max_leaves}{(Optional) Upper bound on the number of leaves to be included in the backbone.
May also be a vector with a length equal to the number of components of G.
A number of leaves of at most max_leaves is estimated by an elbow estimator.
Standard is NA (which is equivalent to +infinity).}

\item{leaves}{(Optional) Exact number of leaves to be included in the backbone.
May also be a vector with a length equal to the number of components of G.
Note that this number may not be achieved, e.g., if there are not enough leaves in the f-pine.}

\item{preprune}{(Optional) Whether to preprune the f-pine, i.e., discard all its leaves once if the cost for CLOF is constant on leaves.
This may significantly improve computation cost, and one may directly obtain the solution in the original pine by adding arbitrary leaves.
Standard is TRUE.}

\item{stdize}{(Optional) Whether to standardize the cost of each component according to its full cost.
Standard is FALSE, which may add bias towards representing larger components in the backbone.}

\item{assign}{(Optional) Whether to construct a branch assignment, marking for each node x which branch(es) represent x.
Standard is FALSE.}

\item{prob}{(Optional & if assign) whether to assign nodes in G to paths according to a probability measure
if FALSE, then nodes are assigned to exactly one path through a one-hot-encoding.
Standard is TRUE.}

\item{constrain_mem}{(Optional & f is not provided) if TRUE, unnecessary distances are never computed.
Standard is FALSE, which currently results in faster computation (with cpp running in the background).}
}
\value{
A list storing the following items:
               - B: the backbone in X encoded as an igraph object.
               - (if constructed) G: the proximity constructed from X (if not stored, then G = X).
               - (if computed) f: the boundary coefficients of the (constructed) graph.
               - pine: an f-pine in G.
               - membership: the membership of the nodes according to the connected components in in G.
               - cost: a data.frame corresponding to the obtained cost according to the number of leaves and components.
               - full_cost: a vector of the maximal obtainable cost of each component.
               - (if CLOF optimizes with vertex-valued function) includedV: a list of lists (one for each connected component) containing the added nodes of G at each iteration.
               - (if CLOF optimizes with edge-valued function) includedE: a list of lists (one for each connected component) containing the added edges of G at each iteration.
               - (if assign) branch: a vector clustering the edges of B into paths.
               - (if assign) prob: a n x k matrix, where n = |V(G)| and k is the number of resulting branches in B, corresponding to a probabilistic assignment of the nodes in G according to these paths.
               - (if assign) palette: a vector of hex code colors, one for each path.
               - (if assign) col: a vector of |V(G)| hex code colors, interpolating between the palette colors according to prob.
}
\description{
Compute a backbone, i.e., a simplified graph-structured topology, of a given graph or point cloud data set X.
}
